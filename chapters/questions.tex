\section{Describe the general characteristics of a scheduling for real-time, possibly including a comparison between Rate Monotonic and EDF. }

\section{Describe the main algorithms for the scheduling of a single-core CPU, paying particular attention to the possible overhead, fairness and reactivity.}

\section{ Detail the boot process of a microcontroller running a C++ bare metal application, from the reset vector to main(). What are the differences compared to a C program.  }


\section{Describe the general characteristics and figures of merit of a CPU scheduler and those more related to the case of Real Time Operating Systems}
\section{Describe the ARM Cortex-M processor by detailing its main features, its registers and the organization and functional principle of the vector table. Extra: What is the CMSIS and which are its main purposes?  }
Q1 See presentation ARM Processors and Architectures - Introduction and Programmer's Model
\section{Describe how interrupts work, detailing the difference between a simple interrupt and one where a context switch occurs.}
Interrupts provide a way to interrupt the normal program flow of the CPU  to handle events generated by peripherals without the expense of polling. A contex switch implies an operating system. In a bare metal embedded device without operating system, no context switch exist. In this case, the interrupt interrupts the execution of the main code (i.e, of the main() function or of a function who is in the call stack of main()). When there is no context switch, the only registers that need to be saved are the ones used by the interrupt service routine (ISR), because at the end of the ISR the code execution will return to the main code, which can be thought of as the only task in the system. This register saving is often done by the compiler. 
This is the timeline:  
++ main code | ISR | main code ++> Time

When you add an OS, an interrupt can wake up a higher priority task than the currently running one (or the time quantum of the task can be expired). So, the task that is running at the end of the interrupt may not be the same as the one running before, as in this timeline: 


++ task1 | ISR | task2 ++> Time


Since each task has its set of registers, upon entering the ISR all registers have to be stored in a perÂ­task data structure within the OS, called a task control block. This is because the registers that will be restored at the end of the ISR will be those of the next task, which may or may not be the one that was interrupted. Not saving all of them (or not restoring all of them) does not work when the before and after task differ. This saving is done by code in the OS, not by the compiler.
